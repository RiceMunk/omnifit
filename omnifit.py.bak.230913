# -*- coding: utf-8 -*-
#Omnifit - beta2
#By Aleksi Suutarinen Sept 2013
#---------------
#Library imports
#---------------
import numpy as np
import pyfits as pf
import matplotlib.pyplot as plt
import pylab
from scipy.optimize import leastsq
from lmfit import minimize, Parameters, Parameter
import re
import warnings
import time
from bhcoat import *
#-----------------
#Class definitions
#-----------------
class spectrum:
  """ Generic 1d spectrum class. """
  def __init__(self,iX,iY,specname='Unknown spectrum',nonData=[],xUnit='Unknown',yUnit='Unknown'):
    """
    Init requires input of x axis values (wavelength etc.) and y axis values (intensity etc.)
    nonData adds extra variable names to the list of variables to be ignored by
    the dropbad function.
    """
    if len(iX) != len(iY):                                  #Check that input is sane
      raise Exception('Input arrays have different sizes.')
    self.x=np.array(iX,dtype='float64')                     #X axis
    self.y=np.array(iY,dtype='float64')                     #Y axis
    self.name=str(specname)                                 #Spectrum name
    self.baselined=False                                    #Has the spectrum been baselined?
    self.convolved=False                                    #Has the spectrum been convolved?
    self.drawstyle='steps-mid'
    self.xUnit=xUnit
    self.yUnit=yUnit
    self.nonData = [
                      'nonData',\
                      'name',\
                      'convolved','baselined',\
                      'drawstyle',\
                      'xUnit','yUnit'\
                   ]
    for cNonData in nonData:                                #Add the extra non-array variable names into nonData
      if not cNonData in self.nonData:
        self.nonData.append(cNonData)                       
    self.dropbad()                                          #Drop bad data.
    self.sort()
  def sort(self):
    """
    Sort the data arrays to go in increasing
    order of x
    """
    sorter=np.argsort(self.x)
    nonDatavars = self.nonData
    ownvarnames = self.__dict__.keys()
    ownvarnames = filter (lambda a: not a in nonDatavars, ownvarnames)
    varlength = len(self.__dict__[ownvarnames[0]])
    iGoodones = np.isfinite(np.ones(varlength))
    for cVarname in ownvarnames:
      self.__dict__[cVarname]=self.__dict__[cVarname][sorter]
  def dropbad(self):
    """
    Make spectrum go through its own vars and drop all the bad ones.
    All variable names in nonData are ignored by this function.
    """
    ignorevars = self.nonData
    ownvarnames = self.__dict__.keys()
    ownvarnames = filter (lambda a: a not in ignorevars, ownvarnames)
    varlength = len(self.__dict__[ownvarnames[0]])
    iGoodones = np.isfinite(np.ones(varlength))
    for cVarname in ownvarnames:
      cVar = self.__dict__[cVarname]
      if len(cVar) != varlength:
        raise Exception('Anomalous variable length detected in spectrum!')
      iGoodones = np.logical_and(iGoodones,np.isfinite(cVar))
    for cVarname in ownvarnames:
      self.__dict__[cVarname]=self.__dict__[cVarname][iGoodones]
  def plot(self,iAx,plotstyle='k-',drawstyle=None,x=None,y=None):
    """
    Plot x,y into given MPL axis.
    They can be overridden with different
    variable names.
    """
    if x:
      cX = self.__dict__[x]
    else:
      cX = self.x
    if y:
      cY = self.__dict__[y]
    else:
      cY = self.y
    if len(cY) != len(cY):
      raise Exception('Plottable x and y values of different length!')
    if drawstyle:
      cDrawstyle=drawstyle
    else:
      cDrawstyle=self.drawstyle
    iAx.plot(cX,cY,plotstyle,drawstyle=cDrawstyle)
  def subspectrum(self,minX,maxX):
    """
    Return a slice of the spectrum as a new spectrum,
    using x axis units as the limits.
    Slice limits are inclusive.
    """
    iSub = np.logical_and(np.greater_equal(self.x,minX),np.less_equal(self.x,maxX))
    newX = self.x[iSub]
    newY = self.y[iSub]
    newSpec = spectrum(newX,newY,specname=self.name+'(cropped)',
                                 nonData=self.nonData,
                                 xUnit=self.xUnit,
                                 yUnit=self.yUnit)
    newSpec.baselined = self.baselined
    newSpec.convolved = self.convolved
    newSpec.drawstyle = self.drawstyle
    for cVarName in self.__dict__.keys():
      if not cVarName in newSpec.__dict__.keys():
        newSpec.__dict__[cVarName]=self.__dict__[cVarName]
    return newSpec
  def interpolate(self,targSpectrum):
    """
    Interpolate spectrum to match target spectrum resolution.
    Does not modify current spectrum. Returns a new one.
    New spectrum metadata is taken from target spectrum.
    """
    if self.xUnit != targSpectrum.xUnit:
      raise Exception('Spectrums have different units on x axis!')
    if self.yUnit != targSpectrum.yUnit:
      raise Exception('Spectrums have different units on y axis!')
    newX=targSpectrum.x
    newY=np.interp(newX,self.x,self.y)
    newSpec=spectrum(newX,newY,
                    specname=self.name+'(interpolated: '+targSpectrum.name+')',
                    nonData=self.nonData,
                    xUnit=self.xUnit,yUnit=self.yUnit)
    newSpec.baselined = targSpectrum.baselined
    newSpec.convolved = targSpectrum.convolved
    newSpec.drawstyle = targSpectrum.drawstyle
    for cVarName in targSpectrum.__dict__.keys():
      if not cVarName in newSpec.__dict__.keys():
        newSpec.__dict__[cVarName]=targSpectrum.__dict__[cVarName]
    return newSpec
    
  def convolve(self,psf):
    """ Convolve spectrum y with given psf """
    if self.convolved:
      warnings.warn('Spectrum '+self.name+' has already been convolved once!',RuntimeWarning)
    if not(self.baselined):
      warnings.warn('Spectrum '+self.name+' has not been baselined yet. Recommend baselining before convolution.',RuntimeWarning)
    self.y=np.convolve(self.y,psf,mode='same')
    self.convolved=True
  def gconvolve(self,fwhm):
    """ Convolve spectrum a gaussian of given fwhm (in units of x axis) """
    deltaX=np.mean(np.diff(self.x))
    gPsf=gaussian(np.arange(-10*fwhm,10*fwhm,deltaX),[1.0,0.0,fwhm])
    self.convolve(gPsf)
  def baseline(self,degree=1,windows=[[0.0,1.0e6]],exclusive=False):
    """
    Correct the y with a new baseline.
    Default mode is inclusive.
    """
    #if in_wl:
      #new_windows=[]
      #for c_window in windows:
        #min_x,max_x=wl2wn(c_window[1]),wl2wn(c_window[0])
        #new_windows.append([min_x,max_x])
      #windows=new_windows
    iBaseline=np.logical_or(np.isinf(self.x),exclusive)
    for cWindow in windows:
      if exclusive:
        iBaseline=np.logical_and(iBaseline,np.logical_or(np.less(self.x,cWindow[0]),np.greater(self.x,cWindow[1])))
      else:
        iBaseline=np.logical_or(iBaseline,np.logical_and(np.greater(self.x,cWindow[0]),np.less(self.x,cWindow[1])))
    baseline = np.polyfit(self.x[iBaseline],self.y[iBaseline],degree)
    if not(np.all(np.isfinite(baseline))):
      raise Exception('Baseline is non-finite!')
    fixedY = self.y
    for cPower in range(degree+1):
      fixedY=fixedY-baseline[degree-cPower]*self.x**cPower
    self.y=fixedY
    self.baselined=True
  def shift(self,amount):
    """
    Shifts the spectrum by amount
    specified, in primary x axis
    units.
    """
    self.x+=amount
  def max(self,checkrange=None):
    """
    Returns maximum y of the spectrum.
    If checkrange is set, returns maximum inside of that range.
    """
    iCheckrange=np.isfinite(self.y)
    if np.any(checkrange):
      minX=checkrange[0]
      maxX=checkrange[1]     
      iCheckrange=np.logical_and(iCheckrange,np.logical_and(
                        np.less_equal(minX,self.x),np.greater_equal(maxX,self.x)))
    return np.max(self.y[iCheckrange])
  def min(self,checkrange=None):
    """
    Returns minimum y of the spectrum.
    If checkrange is set, returns maximum inside of that range.
    """
    iCheckrange=np.isfinite(self.y)
    if np.any(checkrange):
      minX=checkrange[0]
      maxX=checkrange[1]     
      iCheckrange=np.logical_and(iCheckrange,np.logical_and(
                        np.less_equal(minX,self.x),np.greater_equal(maxX,self.x)))
    return np.min(self.y[iCheckrange])
  def info(self):
    print '---'
    print 'Summary for spectrum '+self.name
    print 'x unit: '+self.xUnit
    print 'min(x): '+np.min(self.x)
    print 'max(x): '+np.max(self.x)
    print 'y unit: '+self.yUnit
    print 'min(y): '+np.min(self.y)
    print 'max(y): '+np.max(self.y)
    print 'baseline: '+str(self.baselined)
    print 'convolved: '+str(self.convolved)
    print '---'

class absorptionSpectrum(spectrum):
  """
  An absorption spectrum, with all the
  specific details that involves.
  Units on the y axis are in optical depth
  """
  def __init__(self,iWn,iOd,specname='Unknown absorption spectrum'):
    """
    Init the spectrum. Places iOd on the y axis and
    iWn on the x axis.
    """
    self.od = np.array(iOd,dtype='float64') #Optical depth
    self.wn = np.array(iWn,dtype='float64') #Wave number
    self.wl = wn2wl(self.wn)
    spectrum.__init__(self,self.wn,self.od,specname=specname,xUnit='Wave number',yUnit='Optical depth')
  def plotod(self,iAx,in_wl=False,**kwargs):
    """
    Plot the optical depth spectrum as function of wavenumber
    to given axis unless flag is set.
    """
    if in_wl:
      self.plot(iAx,x='wl',y='od',**kwargs)      
    else:
      self.plot(iAx,x='wn',y='od',**kwargs)


#class labSpectrum(absorptionSpectrum):
  #"""
  #Laboratory spectrum class.
  #Inherits absorptionspectrum class propertries.
  #"""
  #def __init__(self,iWn,iOd,specname='Unknown laboratory spectrum'):
    #"""
    #Init requires input of wavenumber array [cm^-1] and od array.
    #Optional input: Name of spectrum
    #"""
    #absorptionSpectrum.__init__(self,iWn,iOd,specname=specname)

class labSpectrum(absorptionSpectrum):
  """
  Laboratory spectrum class from optical constants.
  Inherits absorptionSpectrum class propertries.
  Does CDE correction to the data.
  """
  def __init__(self,iWn,iN,iK,specname='Unknown CDE-corrected laboratory spectrum'):
    """
    Init requires input of wavenumber array [cm^-1] and od array.
    Optional input: Name of spectrum
    """
    if len(iWn) != len(iN):
      raise TypeError('Input arrays have different sizes.')
    self.cabs,self.cabs_vol,self.cscat_vol,self.ctot=cde_correct(iWn,iN,iK)
    self.n=np.array(iN,dtype='float64')
    self.k=np.array(iK,dtype='float64')
    absorptionSpectrum.__init__(self,iWn,self.cabs_vol,specname=specname)
  def plotnk(self,xrange=None):
    """ Plot the optical constants as function of wavenumber """
    if np.any(xrange):
      minx=xrange[0]
      maxx=xrange[1]
    else:
      minx=np.min(self.wn)
      maxx=np.max(self.wn)
    c_fig=plt.figure()
    c_axis = c_fig.add_subplot(211)
    c_axis.set_title('n')
    c_axis.set_xlim(minx,maxx)
    c_axis.plot(self.wn,self.n,'k-',drawstyle=drawstyle)
    c_axis.plot(self.wn,self.n,'k.',drawstyle=drawstyle)
    c_axis = c_fig.add_subplot(212)
    c_axis.set_title('k')
    c_axis.set_xlim(minx,maxx)
    c_axis.plot(self.wn,self.k,'k-',drawstyle=drawstyle)
    c_axis.plot(self.wn,self.k,'k.',drawstyle=drawstyle)
    plt.show()
    plt.close()

class fitter():
  """
  The omnifitter class.
  The class consists of two major components:
    -The target data points (X and Y; X is assumed same for all functions)
    -The function list, consisting of either lab data or theoretical functions
  """
  def __init__(self,iX,iY,modelname='Unknown model',psf=None,fitRange=None):
    """ Initialise with target spectrum that the rest will be fitted to. """
    if len(iX) != len(iY):
      raise Exception('Input arrays have different sizes.')
    self.fitRange=fitRange
    self.targX=iX
    self.targY=iY
    self.modelname=modelname
    self.psf=psf
    self.funcList=[]
  def add_lab(self,iSpectrum,iParams,funcname=None):
    """
    Add laboratory spectrum to the fitting pool.
    Spectrum must be interpolated and convolved to match with target.
    Uses lmfit params as the parameter list
    """
    if not(funcname):
      funcname=iSpectrum.name
    if len(iSpectrum.x) != len(self.targX):
      raise Exception('Input spectrum has wrong size!')
    self.funcList.append({'type':'lab','shape':iSpectrum.y,'params':iParams,'name':funcname})
  #def add_scatter(self,i_spectrum,i_params,i_grain,funcname=None):
    #"""
    #NOTE: Does not work yet!
    #Add laboratory spectrum (with scattering effects accounted for) to the fitting pool.
    #Spectrum must be interpolated and convolved to match with target.
    #Requires additional input parameter of complex refractive index of the grain.
    #Uses lmfit params as the parameter list
    #"""
    #raise Exception('This has not been implemented yet!')
    #if not(funcname):
      #funcname=i_spectrum.name+'(scattered)'
    #self.funclist.append({'type':'scatter','shape':i_spectrum,'params':i_params,'grain':i_grain,'name':funcname})
  def add_theory(self,iShape,iParams,funcname='Unknown function'):
    """
    Add theoretical function to fitting pool.
    Supported functions:
      gaussian, lorentzian, omni_custom
      (omni_custom needs to be defined separately)
    Uses lmfit params as the parameter list
    """
    supported_functions=['gaussian','lorentzian','flipped_egh']
    if iShape not in supported_functions:
       raise Exception('Function shape not supported. Supported function shapes: '+str(supported_functions))
    self.funcList.append({'type':'theory','shape':iShape,'params':iParams,'name':funcname})

  def perform_fit(self):
    """
    Perform least-squares fitting to the function list
    """
    self.fitPars = self.extract_pars()
    self.fitRes=minimize(self.fit_residual,self.fitPars,epsfcn=0.1)#epsfcn=0.05)
    if not(self.fitRes.success):
      raise Exception('Fitting failed!')
  def fit_residual(self,iPar):
    """ Calculate residual of all the functions compared to the target function """
    residual=1.0*self.targY
    totModel=np.zeros(len(residual))
    for indFunc,cFunc in enumerate(self.funcList):
      oPar=Parameters()
      cParlist = cFunc['params']
      for cPar in cParlist.values():
        ciPar=iPar[self.func_ident(indFunc)+cPar.name]
        oPar.add(cPar.name,
                 value=ciPar.value,vary=ciPar.vary,
                 min=ciPar.min,max=ciPar.max,
                 expr=ciPar.expr)
      residual-=self.parse_function(oPar,cFunc)
    #Crop out not-numbers and fitting range exterior if necessary
    if np.any(self.fitRange):
      fitInd=np.isinf(residual)
      for cRange in self.fitRange:
        fitInd=np.logical_or(fitInd,np.logical_and(
               np.less_equal(cRange[0],self.targX),
               np.greater_equal(cRange[1],self.targX)))
    else:
      fitInd=np.isfinite(residual)
    return residual[fitInd]
  def plot_fitresults(self,iAx,autorange=True,drawstyle='steps-mid',legend=True):
    """ Plot the fitting results to given axis """
    if autorange:
      iAx.set_xlim(np.min(self.targX),np.max(self.targX))
    iAx.plot(self.targX,self.targY,'k-',lw=1,drawstyle=drawstyle)
    legList = [self.modelname]
    #totres=self.targ_y+self.fitres.residual
    totRes=np.zeros(len(self.targY))
    for indFunc,cFunc in enumerate(self.funcList):
      oPar=Parameters()
      cParList = cFunc['params']
      for cPar in cParList.values():
        cFitPar=self.fitPars[self.func_ident(indFunc)+cPar.name]
        oPar.add(cPar.name,
                 value=cFitPar.value,vary=cFitPar.vary,
                 min=cFitPar.min,max=cFitPar.max,
                 expr=cFitPar.expr)
      funcRes = self.parse_function(oPar,cFunc)
      totRes+=funcRes
      iAx.plot(self.targX,funcRes,lw=2,drawstyle=drawstyle)
      legList.append(cFunc['name'])
    legList.append('Total fit')
    iAx.plot(self.targX,totRes,lw=3,drawstyle=drawstyle)
    if legend:
      iAx.legend(legList,shadow=True)
  def fit_results(self):
    """ Return all fitting results as a dictionary"""
    oResults={}
    for indFunc,cFunc in enumerate(self.funcList):
      oKeyname_base=cFunc['name']
      oKeyind=0
      oKeyname=oKeyname_base
      while oResults.__contains__(oKeyname): #In case of duplicate function names
        oKeyind+=1
        oKeyname=oKeyname_base+'(duplicate '+str(oKeyind)+')'
      oResults[cFunc['name']]=self.fit_result(indFunc)
    return oResults
  def fit_result(self,indFunc):
    """ Return fitting results for a specific function """
    oParlist=self.funcList[indFunc]['params']
    for cParname in oParlist.keys():
      coPar=self.fitPars[self.func_ident(indFunc)+cParname]
      coPar.name=cParname
      oParlist[cParname]=coPar
    return oParlist
  def parse_function(self,iPar,iFunc):
    """ Parse the input function, insert parameters, return result """
    if iFunc['type']=='lab':
      shiftData=np.interp(self.targX+iPar['shift'].value,self.targX,iFunc['shape'])
      funcRes=muldata(shiftData,iPar['mul'].value)
      #funcRes=muldata(iFunc['shape'],iPar['mul'].value)
    elif iFunc['type']=='scatter':
      funcres=scatterdata(self.targX,iFunc['shape'],iFunc['grain'],iPar,self.psf)
    elif iFunc['type']=='theory':
      funcRes=globals()[iFunc['shape']](self.targX,iPar,self.psf)
    else:
      raise Exception('Unknown function type!')
    return funcRes
  def extract_pars(self):
    """
    Extract the paramers from the function list so they can be manipulated by the residual minimization routines.
    """
    oPars=Parameters()
    for indFunc,cFunc in enumerate(self.funcList):
      cParlist = cFunc['params']
      for cPar in cParlist.values():
        oPars.add(self.func_ident(indFunc)+cPar.name,
                  value=cPar.value,vary=cPar.vary,
                  min=cPar.min,max=cPar.max,
                  expr=cPar.expr)
    return oPars
  def func_ident(self,indFunc):
    """ 
    Return function identifier string.
    Used with function fitting
    """
    return '__Func'+str(indFunc)+'__'
  #def reconstruct_parray(self,i_varpar,i_fitfunc): ###OBSOLETE###
    #"""
    #Reconstruct a parameter array suitable for feeding into the functions from knowledge which of the parameters are variable and which ones are fixed.
    #Called exclusively by fit_residual.
    #"""
    #guess=i_fitfunc['guess']
    #fixpar=i_fitfunc['fixed']
    #numpars=len(guess)
    #out_par=np.zeros(numpars)
    #for ind_par in range(numpars):
      #if fixpar[ind_par]:
        #out_par[ind_par]=guess[ind_par]
      #else:
        #out_par[ind_par]=i_varpar[0]
        #i_varpar=np.delete(i_varpar,0)
    #if len(i_varpar):
      #warnings.warn('Unpopped varpars still exist!',RuntimeWarning)
    #return out_par
#--------------------------
#Misc. function definitions
#--------------------------
def wl2wn(iWavelength):
  """
  Convert wavelength [um] to wavenumber [cm^-1]
  """
  return 1.0e4/iWavelength

def wn2wl(iWavenumber):
  """
  Convert wavenumber [cm^-1] to wavelength [um]
  """
  return 1.0e4/iWavenumber

def cde_correct(wn,n,k):
  """
  CDE correction to  n,k data
  """
  wl=wn2wl(wn)
  m=np.vectorize(complex)(n,k)
  cabs_vol=np.empty(0)
  cabs=np.empty(0)
  cscat_vol=np.empty(0)
  for c_wn,c_wl,c_m in zip(wn,wl,m):
    m2=c_m**2.0
    im_part=((m2/(m2-1))*np.log(m2)).imag
    cabs_vol=np.hstack([cabs_vol,2.*(2.*np.pi/c_wl)*im_part])
    t_cabs=c_wn*(2.0*c_m.imag/(c_m.imag-1))*np.log10(c_m.imag)
    cabs=np.hstack([cabs,t_cabs])
    cscat_vol=np.hstack([cscat_vol,(c_wn**3.0/(6*np.pi))*t_cabs])
  ctot=cabs+cscat_vol
  return cabs,cabs_vol,cscat_vol,ctot
#----------------------------
#Fitting function definitions
#----------------------------
def scatterdata(wavenum,lab,ref_core,par,psf=None):
  """
  Scatter lab data with bhcoat
  Assumes x axis is wavenumber
  """
  radius_core=par['radius_core'].value
  radius_mantle=par['radius_mantle'].value
  wavelen=wn2wl(wavenum)*1.0e-6
  out_y=np.empty(0)
  for c_wavelen in wavelen:
    c_n=np.interp(c_wavelen,lab.wl,lab.n)
    c_k=np.interp(c_wavelen,lab.wl,lab.k)
    ref_mantle=np.complex(c_n,c_k)
    #Qext=bhcoat(c_wavelen,radius_core,radius_mantle,ref_core,ref_mantle)['Qext']
    Qsca=bhcoat(c_wavelen,radius_core,radius_mantle,ref_core,ref_mantle)['Qsca']
    Csca=Qsca*np.pi*radius_mantle**2.0
    out_y = np.hstack((out_y,Csca))#3*Qsca/(4*radius_mantle)))
  c_fig=plt.figure()
  c_axis = c_fig.add_subplot(111)
  c_axis.plot(wavenum,out_y,'k-',drawstyle=drawstyle)
  plt.show()
  plt.close()
  if not(np.any(psf)):
    return out_y
  else:
    return np.convolve(out_y,psf,mode='same')
def muldata(data,mul):#par):
  """ Multiply data with par and return result """
  return mul*data

def flipped_egh(x,par,psf):
  """
  Flipped EGH (exponential-gaussian hybrid)
  For normal EGH, see:
  Lan & Jorgenson, Journal of Chromatography A, 915 (2001) 1-13
  Parameters:
  H = magnitude of peak maximum
  xR = retention time
  w = std. dev of precursor gaussian
  tau = time constant of precursor exponential
  """
  H=par['H'].value
  xR=par['xR'].value
  w=par['w'].value
  tau=par['tau'].value
  expFactor = np.exp((-1.0*(xR-x)**2.0)/(2.0*w*w+tau*(xR-x)))
  out_y = np.where(2.0*w*w+tau*(xR-x)>0,H*expFactor,0.0)
  if not(np.any(psf)):
    return out_y
  else:
    return np.convolve(out_y,psf,mode='same')

def gaussian(x,par,psf=None):
  """ A gaussian function """
  peak=par['peak'].value
  fwhm=par['fwhm'].value
  pos=par['pos'].value
  out_y=peak*np.exp(-2.35*(x-pos)**2./fwhm**2.)
  if not(np.any(psf)):
    return out_y
  else:
    return np.convolve(out_y,psf,mode='same')
def lorentzian(x,par,psf=None):
  """ A lorentzian function """
  lor1=par['lor1'].value
  lor2=par['lor2'].value
  lor3=par['lor3'].value
  peak=par['peak'].value
  pos=par['pos'].value
  lorentz_oscillator=lor1+lor2**2./(pos**2.-x**2.-lor3*x*1.j)
  out_y=peak*x*np.imag(2.*lorentz_oscillator*np.log10(lorentz_oscillator)/(lorentz_oscillator-1.))
  if not(np.any(psf)):
    return out_y
  else:
    return np.convolve(out_y,psf,mode='same')
